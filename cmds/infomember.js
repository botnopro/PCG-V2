const fs = require("fs");
const path = require("path");
const axios = require("axios");

module.exports = {
  config: {
    name: "info",
    version: "1.7",
    author: "D∆∞∆°ng S√∫",
    countDown: 5,
    role: 0,
    shortDescription: "Qu·∫£n l√Ω th√¥ng tin ng∆∞·ªùi d√πng",
    longDescription: "Th√™m, s·ª≠a, xem th√¥ng tin c√° nh√¢n (t√™n, bi·ªát danh, tu·ªïi, s·ªü th√≠ch, ·∫£nh/video/GIF). Nh·∫≠p 'cancel' ƒë·ªÉ h·ªßy, 'back' ƒë·ªÉ quay l·∫°i b∆∞·ªõc tr∆∞·ªõc.",
    category: "Ti·ªán √≠ch",
    guide: `{pn} add - Th√™m th√¥ng tin c√° nh√¢n\n`
         + `{pn} name <t√™n> - S·ª≠a t√™n\n`
         + `{pn} nickname <bi·ªát danh> - S·ª≠a bi·ªát danh\n`
         + `{pn} age <tu·ªïi/nƒÉm sinh> - S·ª≠a tu·ªïi\n`
         + `{pn} hobby <s·ªü th√≠ch> - S·ª≠a s·ªü th√≠ch\n`
         + `{pn} file - S·ª≠a ·∫£nh/video/GIF (reply v·ªõi file)\n`
         + `{pn} [@tag] - Xem th√¥ng tin ng∆∞·ªùi ƒë∆∞·ª£c tag\n`
         + `{pn} me - Xem th√¥ng tin b·∫£n th√¢n\n`
         + `{pn} - Xem th√¥ng tin b·∫£n th√¢n\n`
         + `Nh·∫≠p 'cancel' ƒë·ªÉ h·ªßy, 'back' ƒë·ªÉ quay l·∫°i b∆∞·ªõc tr∆∞·ªõc khi ƒëang th√™m th√¥ng tin.`,
    packages: ["axios"]
  },

  onStart: async function ({ api, args, message, event, usersData }) {
    const { threadID, senderID, mentions, messageReply } = event;
    const infoDir = path.join(__dirname, "../../info");
    const infoFile = path.join(infoDir, "info.json");

    if (!fs.existsSync(infoDir)) {
      fs.mkdirSync(infoDir, { recursive: true });
    }

    let userInfo = fs.existsSync(infoFile) ? JSON.parse(fs.readFileSync(infoFile)) : {};

    const superscriptMap = {
      0: "‚Å∞", 1: "¬π", 2: "¬≤", 3: "¬≥", 4: "‚Å¥", 5: "‚Åµ",
      6: "‚Å∂", 7: "‚Å∑", 8: "‚Å∏", 9: "‚Åπ"
    };
    const toSuperscript = (num) => String(num).split("").map(digit => superscriptMap[digit]).join("");

    // H√†m chuy·ªÉn ƒë·ªïi sang font Bold Italic Serif (ch·ªâ cho nh√£n, kh√¥ng √°p d·ª•ng cho gi√° tr·ªã ti·∫øng Vi·ªát)
    const toBoldItalicSerif = (text) => {
      const charMap = {
    'A': 'ùî∏', 'B': 'ùîπ', 'C': '‚ÑÇ', 'D': 'ùîª', 'E': 'ùîº', 'F': 'ùîΩ', 'G': 'ùîæ', 'H': '‚Ñç', 'I': 'ùïÄ', 'J': 'ùïÅ', 'K': 'ùïÇ', 'L': 'ùïÉ', 'M': 'ùïÑ',
    'N': '‚Ñï', 'O': 'ùïÜ', 'P': '‚Ñô', 'Q': '‚Ñö', 'R': '‚Ñù', 'S': 'ùïä', 'T': 'ùïã', 'U': 'ùïå', 'V': 'ùïç', 'W': 'ùïé', 'X': 'ùïè', 'Y': 'ùïê', 'Z': '‚Ñ§',
    'a': 'ùïí', 'b': 'ùïì', 'c': 'ùïî', 'd': 'ùïï', 'e': 'ùïñ', 'f': 'ùïó', 'g': 'ùïò', 'h': 'ùïô', 'i': 'ùïö', 'j': 'ùïõ', 'k': 'ùïú', 'l': 'ùïù', 'm': 'ùïû',
    'n': 'ùïü', 'o': 'ùï†', 'p': 'ùï°', 'q': 'ùï¢', 'r': 'ùï£', 's': 'ùï§', 't': 'ùï•', 'u': 'ùï¶', 'v': 'ùïß', 'w': 'ùï®', 'x': 'ùï©', 'y': 'ùï™', 'z': 'ùï´',
    '0': 'ùüò', '1': 'ùüô', '2': 'ùüö', '3': 'ùüõ', '4': 'ùüú', '5': 'ùüù', '6': 'ùüû', '7': 'ùüü', '8': 'ùü†', '9': 'ùü°',
    ' ': ' ', ':': ':', '-': '-', '.': '.', '!': '!', '?': '?', ',': ',', '(': '(', ')': ')',

    // H·ªó tr·ª£ ti·∫øng Vi·ªát c∆° b·∫£n (ƒë∆∞·ª£c gh√©p d·∫•u)
    'ƒÉ': 'ùïíÃÜ', '·∫Ø': 'ùïíÃÜÃÅ', '·∫±': 'ùïíÃÜÃÄ', '·∫≥': 'ùïíÃÜÃâ', '·∫µ': 'ùïíÃÜÃÉ', '·∫∑': 'ùïíÃÜÃ£',
    '√¢': 'ùïíÃÇ', '·∫•': 'ùïíÃÇÃÅ', '·∫ß': 'ùïíÃÇÃÄ', '·∫©': 'ùïíÃÇÃâ', '·∫´': 'ùïíÃÇÃÉ', '·∫≠': 'ùïíÃÇÃ£',
    '√™': 'ùïñÃÇ', '·∫ø': 'ùïñÃÇÃÅ', '·ªÅ': 'ùïñÃÇÃÄ', '·ªÉ': 'ùïñÃÇÃâ', '·ªÖ': 'ùïñÃÇÃÉ', '·ªá': 'ùïñÃÇÃ£',
    '√¥': 'ùï†ÃÇ', '·ªë': 'ùï†ÃÇÃÅ', '·ªì': 'ùï†ÃÇÃÄ', '·ªï': 'ùï†ÃÇÃâ', '·ªó': 'ùï†ÃÇÃÉ', '·ªô': 'ùï†ÃÇÃ£',
    '∆°': 'ùï†Ãõ', '·ªõ': 'ùï†ÃõÃÅ', '·ªù': 'ùï†ÃõÃÄ', '·ªü': 'ùï†ÃõÃâ', '·ª°': 'ùï†ÃõÃÉ', '·ª£': 'ùï†ÃõÃ£',
    '∆∞': 'ùï¶Ãõ', '·ª©': 'ùï¶ÃõÃÅ', '·ª´': 'ùï¶ÃõÃÄ', '·ª≠': 'ùï¶ÃõÃâ', '·ªØ': 'ùï¶ÃõÃÉ', '·ª±': 'ùï¶ÃõÃ£',
    'ƒë': 'ùïïÃ£',
    '√°': 'ùïíÃÅ', '√†': 'ùïíÃÄ', '·∫£': 'ùïíÃâ', '√£': 'ùïíÃÉ', '·∫°': 'ùïíÃ£',
    '√©': 'ùïñÃÅ', '√®': 'ùïñÃÄ', '·∫ª': 'ùïñÃâ', '·∫Ω': 'ùïñÃÉ', '·∫π': 'ùïñÃ£',
    '√≠': 'ùïöÃÅ', '√¨': 'ùïöÃÄ', '·ªâ': 'ùïöÃâ', 'ƒ©': 'ùïöÃÉ', '·ªã': 'ùïöÃ£',
    '√∫': 'ùï¶ÃÅ', '√π': 'ùï¶ÃÄ', '·ªß': 'ùï¶Ãâ', '≈©': 'ùï¶ÃÉ', '·ª•': 'ùï¶Ã£',
    '√Ω': 'ùï™ÃÅ', '·ª≥': 'ùï™ÃÄ', '·ª∑': 'ùï™Ãâ', '·ªπ': 'ùï™ÃÉ', '·ªµ': 'ùï™Ã£',
    'ƒÇ': 'ùîÑÃÜ', '√Ç': 'ùîÑÃÇ', '√ä': 'ùîàÃÇ', '√î': 'ùîíÃÇ', '∆†': 'ùîíÃõ', '∆Ø': 'ùîòÃõ', 'ƒê': 'ùîáÃ£'
  };
      return text.split("").map(char => charMap[char] || char).join("");
    };

    try {
      if (args[0] === "add") {
        userInfo[senderID] = { ...userInfo[senderID], step: "name", prevSteps: [] };
        fs.writeFileSync(infoFile, JSON.stringify(userInfo, null, 2));
        return message.reply("Nh·∫≠p t√™n c·ªßa b·∫°n :3");
      } else if (args[0] === "name" && args[1]) {
        if (!userInfo[senderID] || !userInfo[senderID].name) {
          return message.reply("B·∫°n ch∆∞a ƒëi·ªÅn th√¥ng tin! Vui l√≤ng ghi .info add ƒë·ªÉ ƒëƒÉng k√Ω");
        }
        const nameInput = args.slice(1).join(" ").trim();
        if (nameInput.length > 20 || nameInput.includes("\n")) {
          return message.reply("T√™n t·ªëi ƒëa 20 k√Ω t·ª± v√† kh√¥ng ƒë∆∞·ª£c xu·ªëng d√≤ng, vui l√≤ng nh·∫≠p l·∫°i");
        }
        userInfo[senderID].name = nameInput;
        fs.writeFileSync(infoFile, JSON.stringify(userInfo, null, 2));
        return message.reply(`ƒê√£ s·ª≠a t√™n th√†nh: ${nameInput}`);
      } else if (args[0] === "nickname" && args[1]) {
        if (!userInfo[senderID] || !userInfo[senderID].name) {
          return message.reply("B·∫°n ch∆∞a ƒëi·ªÅn th√¥ng tin! Vui l√≤ng ghi .info add ƒë·ªÉ ƒëƒÉng k√Ω");
        }
        const nicknameInput = args.slice(1).join(" ").trim();
        userInfo[senderID].nickname = nicknameInput;
        const nicknameWithAge = `${nicknameInput} ${toSuperscript(userInfo[senderID].age)}`;
        try {
          await api.changeNickname(nicknameWithAge, threadID, senderID);
          userInfo[senderID].nickname = nicknameInput;
          fs.writeFileSync(infoFile, JSON.stringify(userInfo, null, 2));
          return message.reply(`ƒê√£ s·ª≠a bi·ªát danh th√†nh: ${nicknameInput}\nüî∞ƒê√£ ƒë·ªïi t√™n b·∫°n th√†nh: ${nicknameWithAge}`);
        } catch (error) {
          console.error("Error changing nickname:", error);
          return message.reply(`‚ö†Ô∏èB·ªã l·ªói trong qu√° tr√¨nh ƒë·ªïi t√™n\nƒê√£ s·ª≠a bi·ªát danh th√†nh: ${nicknameInput}`);
        }
      } else if (args[0] === "age" && args[1]) {
        if (!userInfo[senderID] || !userInfo[senderID].name) {
          return message.reply("B·∫°n ch∆∞a ƒëi·ªÅn th√¥ng tin! Vui l√≤ng ghi .info add ƒë·ªÉ ƒëƒÉng k√Ω");
        }
        let age;
        const inputAge = args[1].trim().toLowerCase();

        const yearMatch = inputAge.match(/^(2k|2k[0-1][0-9]?|19[9][0-9]|20[0-1][0-9])$/);
        if (yearMatch) {
          let year = inputAge;
          if (year.startsWith("2k")) {
            year = year === "2k" ? "2000" : `20${year.slice(2).padStart(2, "0")}`;
          } else if (year.match(/^(19|20)\d$/)) {
            year = year.padStart(4, "19");
          }
          year = parseInt(year);
          if (year >= 1990 && year <= 2019) {
            age = 2025 - year;
          } else {
            return message.reply("NƒÉm sinh ph·∫£i t·ª´ 1990 ƒë·∫øn 2019:");
          }
        } else {
          age = parseInt(inputAge);
          if (isNaN(age) || age < 6 || age > 120) {
            return message.reply("Tu·ªïi ph·∫£i l√† s·ªë h·ª£p l·ªá: v√≠ d·ª• 18 ho·∫∑c 2006");
          }
        }

        userInfo[senderID].age = age;
        const nicknameWithAge = `${userInfo[senderID].nickname} ${toSuperscript(age)}`;
        try {
          await api.changeNickname(nicknameWithAge, threadID, senderID);
          fs.writeFileSync(infoFile, JSON.stringify(userInfo, null, 2));
          return message.reply(`ƒê√£ s·ª≠a tu·ªïi th√†nh: ${age}\nüî∞ƒê√£ ƒë·ªïi t√™n b·∫°n th√†nh: ${nicknameWithAge}`);
        } catch (error) {
          console.error("Error changing nickname:", error);
          return message.reply(`‚ö†Ô∏èB·ªã l·ªói trong qu√° tr√¨nh ƒë·ªïi t√™n\nƒê√£ s·ª≠a tu·ªïi th√†nh: ${age}`);
        }
      } else if (args[0] === "hobby" && args[1]) {
        if (!userInfo[senderID] || !userInfo[senderID].name) {
          return message.reply("B·∫°n ch∆∞a ƒëi·ªÅn th√¥ng tin! Vui l√≤ng ghi .info add ƒë·ªÉ ƒëƒÉng k√Ω");
        }
        const hobbyInput = args.slice(1).join(" ").trim();
        userInfo[senderID].hobby = hobbyInput;
        fs.writeFileSync(infoFile, JSON.stringify(userInfo, null, 2));
        return message.reply(`ƒê√£ s·ª≠a s·ªü th√≠ch th√†nh: ${hobbyInput}`);
      } else if (args[0] === "file") {
        if (!userInfo[senderID] || !userInfo[senderID].name) {
          return message.reply("B·∫°n ch∆∞a ƒëi·ªÅn th√¥ng tin! Vui l√≤ng ghi .info add ƒë·ªÉ ƒëƒÉng k√Ω");
        }
        if (!messageReply || !messageReply.attachments || !messageReply.attachments[0]) {
          return message.reply("Vui l√≤ng reply tin nh·∫Øn v·ªõi m·ªôt ·∫£nh, video ho·∫∑c GIF (t·ªëi ƒëa 14MB)!");
        }

        const attachment = messageReply.attachments[0];
        const validTypes = ["photo", "video", "animated_image"];
        if (!validTypes.includes(attachment.type)) {
          return message.reply("Vui l√≤ng reply v·ªõi m·ªôt ·∫£nh, video ho·∫∑c GIF!");
        }

        // T·∫£i file ƒë·ªÉ ki·ªÉm tra k√≠ch th∆∞·ªõc
        const response = await axios.get(attachment.url, { responseType: "arraybuffer" });
        const fileSize = Buffer.from(response.data).length;
        const maxSize = 14 * 1024 * 1024; // 14MB

        if (fileSize > maxSize) {
          return message.reply("File v∆∞·ª£t qu√° 14MB, vui l√≤ng g·ª≠i file nh·ªè h∆°n!");
        }

        // X√°c ƒë·ªãnh ƒëu√¥i file
        let ext;
        switch (attachment.type) {
          case "photo":
            ext = ".jpg";
            break;
          case "video":
            ext = ".mp4";
            break;
          case "animated_image":
            ext = ".gif";
            break;
        }

        // X√≥a file c≈© n·∫øu c√≥
        if (userInfo[senderID].attachment) {
          const oldFilePath = path.join(infoDir, userInfo[senderID].attachment);
          if (fs.existsSync(oldFilePath)) {
            fs.unlinkSync(oldFilePath);
          }
        }

        const filePath = path.join(infoDir, `${senderID}_${Date.now()}${ext}`);
        fs.writeFileSync(filePath, Buffer.from(response.data));

        userInfo[senderID].attachment = path.basename(filePath);
        fs.writeFileSync(infoFile, JSON.stringify(userInfo, null, 2));
        return message.reply("ƒê√£ s·ª≠a file th√†nh c√¥ng!");
      } else if (args[0] === "me" || args.length === 0) {
        if (!userInfo[senderID] || !userInfo[senderID].name) {
          return message.reply("B·∫°n ch∆∞a ƒëi·ªÅn th√¥ng tin! Vui l√≤ng ghi .info add ƒë·ªÉ ƒëƒÉng k√Ω");
        }
        const { name, nickname, age, hobby, attachment } = userInfo[senderID];
        const msg = `${toBoldItalicSerif("‚ÑπÔ∏èTh√¥ng tin c·ªßa b·∫°n:")}\n`
                  + `${toBoldItalicSerif("‚öúÔ∏èT√™n:")} ${name}\n`
                  + `${toBoldItalicSerif("‚öúÔ∏èBi·ªát danh:")} ${nickname}\n`
                  + `${toBoldItalicSerif("‚öúÔ∏èTu·ªïi:")} ${age}\n`
                  + `${toBoldItalicSerif("‚öúÔ∏èS·ªü th√≠ch:")} ${hobby}`;
        return api.sendMessage(
          { body: msg, attachment: attachment ? fs.createReadStream(path.join(infoDir, attachment)) : null },
          threadID
        );
      } else if (Object.keys(mentions).length > 0) {
        const targetID = Object.keys(mentions)[0];
        if (!userInfo[targetID] || !userInfo[targetID].name) {
          return message.reply("Ng∆∞·ªùi d√πng ch∆∞a ƒëi·ªÅn th√¥ng tin!");
        }
        const { name, nickname, age, hobby, attachment } = userInfo[targetID];
        const msg = `${toBoldItalicSerif(`‚ÑπÔ∏èTh√¥ng tin c·ªßa ${mentions[targetID].replace(/@/g, "")}:`)}\n`
                  + `${toBoldItalicSerif("‚öúÔ∏èT√™n:")} ${name}\n`
                  + `${toBoldItalicSerif("‚öúÔ∏èBi·ªát danh:")} ${nickname}\n`
                  + `${toBoldItalicSerif("‚öúÔ∏èTu·ªïi:")} ${age}\n`
                  + `${toBoldItalicSerif("‚öúÔ∏èS·ªü th√≠ch:")} ${hobby}`;
        return api.sendMessage(
          { body: msg, attachment: attachment ? fs.createReadStream(path.join(infoDir, attachment)) : null },
          threadID
        );
      } else {
        return message.reply("C√∫ ph√°p kh√¥ng h·ª£p l·ªá! S·ª≠ d·ª•ng `.info`, `.info me`, `.info @tag`, `.info add`, `.info name <t√™n>`, `.info nickname <bi·ªát danh>`, `.info age <tu·ªïi>`, `.info hobby <s·ªü th√≠ch>`, ho·∫∑c `.info file` (reply v·ªõi file).");
      }
    } catch (error) {
      console.error("Error in onStart:", error);
      return message.reply("ƒê√£ x·∫£y ra l·ªói, vui l√≤ng th·ª≠ l·∫°i sau!");
    }
  },

  onChat: async function ({ api, event, message, usersData }) {
    const { threadID, senderID, body } = event;
    const infoDir = path.join(__dirname, "../../info");
    const infoFile = path.join(infoDir, "info.json");

    if (!fs.existsSync(infoFile)) return;
    let userInfo = JSON.parse(fs.readFileSync(infoFile));

    if (!userInfo[senderID] || !userInfo[senderID].step) return;

    const step = userInfo[senderID].step;
    const input = body.trim().toLowerCase();

    const superscriptMap = {
      0: "‚Å∞", 1: "¬π", 2: "¬≤", 3: "¬≥", 4: "‚Å¥", 5: "‚Åµ",
      6: "‚Å∂", 7: "‚Å∑", 8: "‚Å∏", 9: "‚Åπ"
    };
    const toSuperscript = (num) => String(num).split("").map(digit => superscriptMap[digit]).join("");

    const stepsOrder = ["name", "nickname", "age", "hobby", "attachment"];
    const prompts = {
      name: "Nh·∫≠p t√™n c·ªßa b·∫°n :3",
      nickname: "Bi·ªát danh c·ªßa b·∫°n ho·∫∑c t√™n trong game l√† g√¨ :b",
      age: "Vui l√≤ng nh·∫≠p nƒÉm sinh c·ªßa b·∫°n :>",
      hobby: "S·ªü th√≠ch c·ªßa b·∫°n l√† g√¨?",
      attachment: "H√£y g·ª≠i ·∫£nh, video ho·∫∑c GIF (t·ªëi ƒëa 14MB) ƒë·ªÉ ho√†n t·∫•t th√¥ng tin"
    };

    try {
      if (input === "cancel") {
        userInfo[senderID] = { ...userInfo[senderID], step: undefined, prevSteps: [] };
        fs.writeFileSync(infoFile, JSON.stringify(userInfo, null, 2));
        return message.reply("ƒê√£ h·ªßy qu√° tr√¨nh ƒëi·ªÅn th√¥ng tin!");
      }

      if (input === "back") {
        const prevSteps = userInfo[senderID].prevSteps || [];
        if (prevSteps.length === 0) {
          return message.reply("B·∫°n ƒëang ·ªü b∆∞·ªõc ƒë·∫ßu ti√™n, kh√¥ng th·ªÉ quay l·∫°i!");
        }
        const prevStep = prevSteps.pop();
        userInfo[senderID].step = prevStep;
        userInfo[senderID].prevSteps = prevSteps;
        fs.writeFileSync(infoFile, JSON.stringify(userInfo, null, 2));
        return message.reply(prompts[prevStep]);
      }

      if (step === "name") {
        const nameInput = body.trim();
        if (nameInput.length > 20 || body.includes("\n")) {
          return message.reply("T√™n t·ªëi ƒëa 20 k√Ω t·ª± v√† kh√¥ng ƒë∆∞·ª£c xu·ªëng d√≤ng, vui l√≤ng nh·∫≠p l·∫°i");
        }
        userInfo[senderID].name = nameInput;
        userInfo[senderID].prevSteps = userInfo[senderID].prevSteps || [];
        userInfo[senderID].prevSteps.push(step);
        userInfo[senderID].step = "nickname";
        fs.writeFileSync(infoFile, JSON.stringify(userInfo, null, 2));
        return message.reply("Bi·ªát danh c·ªßa b·∫°n ho·∫∑c t√™n trong game l√† g√¨ :b");
      } else if (step === "nickname") {
        userInfo[senderID].nickname = body.trim();
        userInfo[senderID].prevSteps.push(step);
        userInfo[senderID].step = "age";
        fs.writeFileSync(infoFile, JSON.stringify(userInfo, null, 2));
        return message.reply("Vui l√≤ng nh·∫≠p nƒÉm sinh c·ªßa b·∫°n :>");
      } else if (step === "age") {
        let age;
        const inputAge = body.trim().toLowerCase();

        const yearMatch = inputAge.match(/^(2k|2k[0-1][0-9]?|19[9][0-9]|20[0-1][0-9])$/);
        if (yearMatch) {
          let year = inputAge;
          if (year.startsWith("2k")) {
            year = year === "2k" ? "2000" : `20${year.slice(2).padStart(2, "0")}`;
          } else if (year.match(/^(19|20)\d$/)) {
            year = year.padStart(4, "19");
          }
          year = parseInt(year);
          if (year >= 1990 && year <= 2019) {
            age = 2025 - year;
          } else {
            return message.reply("NƒÉm sinh ph·∫£i t·ª´ 1990 ƒë·∫øn 2019:");
          }
        } else {
          age = parseInt(inputAge);
          if (isNaN(age) || age < 6 || age > 120) {
            return message.reply("Tu·ªïi ph·∫£i l√† s·ªë h·ª£p l·ªá: v√≠ d·ª• 18 ho·∫∑c 2006");
          }
        }

        userInfo[senderID].age = age;
        userInfo[senderID].prevSteps.push(step);
        userInfo[senderID].step = "hobby";
        fs.writeFileSync(infoFile, JSON.stringify(userInfo, null, 2));
        return message.reply("S·ªü th√≠ch c·ªßa b·∫°n l√† g√¨?");
      } else if (step === "hobby") {
        userInfo[senderID].hobby = body.trim();
        userInfo[senderID].prevSteps.push(step);
        userInfo[senderID].step = "attachment";
        fs.writeFileSync(infoFile, JSON.stringify(userInfo, null, 2));
        return message.reply("H√£y g·ª≠i ·∫£nh, video ho·∫∑c GIF (t·ªëi ƒëa 14MB) ƒë·ªÉ ho√†n t·∫•t th√¥ng tin");
      } else if (step === "attachment") {
        if (!event.attachments || !event.attachments[0]) {
          return message.reply("Vui l√≤ng g·ª≠i m·ªôt ·∫£nh, video ho·∫∑c GIF! G·ª≠i l·∫°i ho·∫∑c nh·∫≠p 'cancel' ƒë·ªÉ h·ªßy:");
        }

        const attachment = event.attachments[0];
        const validTypes = ["photo", "video", "animated_image"];
        if (!validTypes.includes(attachment.type)) {
          return message.reply("Vui l√≤ng g·ª≠i m·ªôt ·∫£nh, video ho·∫∑c GIF! G·ª≠i l·∫°i ho·∫∑c nh·∫≠p 'cancel' ƒë·ªÉ h·ªßy:");
        }

        // T·∫£i file ƒë·ªÉ ki·ªÉm tra k√≠ch th∆∞·ªõc
        const response = await axios.get(attachment.url, { responseType: "arraybuffer" });
        const fileSize = Buffer.from(response.data).length;
        const maxSize = 14 * 1024 * 1024; // 14MB

        if (fileSize > maxSize) {
          return message.reply("File v∆∞·ª£t qu√° 14MB, vui l√≤ng g·ª≠i file nh·ªè h∆°n!");
        }

        // X√≥a file c≈© n·∫øu c√≥
        if (userInfo[senderID].attachment) {
          const oldFilePath = path.join(infoDir, userInfo[senderID].attachment);
          if (fs.existsSync(oldFilePath)) {
            fs.unlinkSync(oldFilePath);
          }
        }

        // X√°c ƒë·ªãnh ƒëu√¥i file
        let ext;
        switch (attachment.type) {
          case "photo":
            ext = ".jpg";
            break;
          case "video":
            ext = ".mp4";
            break;
          case "animated_image":
            ext = ".gif";
            break;
        }

        const filePath = path.join(infoDir, `${senderID}_${Date.now()}${ext}`);
        fs.writeFileSync(filePath, Buffer.from(response.data));

        userInfo[senderID].attachment = path.basename(filePath);
        userInfo[senderID].step = undefined;
        userInfo[senderID].prevSteps = [];
        fs.writeFileSync(infoFile, JSON.stringify(userInfo, null, 2));

        const nicknameWithAge = `${userInfo[senderID].nickname} ${toSuperscript(userInfo[senderID].age)}`;
        try {
          await api.changeNickname(nicknameWithAge, threadID, senderID);
          return message.reply(`üî∞ƒê√£ ƒë·ªïi t√™n b·∫°n th√†nh: ${nicknameWithAge}\n‚úÖB·∫°n ƒë√£ ƒëƒÉng k√Ω th√†nh c√¥ng ƒë·ªÉ xem th√¥ng tin g√µ: \n .info me`);
        } catch (error) {
          console.error("Error changing nickname:", error);
          return message.reply(`‚ö†Ô∏èB·ªã l·ªói trong qu√° tr√¨nh ƒë·ªïi t√™n c·ªßa b·∫°n\n ‚úÖB·∫°n ƒë√£ ƒëƒÉng k√Ω th√†nh c√¥ng ƒë·ªÉ xem th√¥ng tin g√µ: \n .info me`);
        }
      }
    } catch (error) {
      console.error("Error in onChat:", error);
      return message.reply("ƒê√£ x·∫£y ra l·ªói, vui l√≤ng th·ª≠ l·∫°i sau!");
    }
  }
};
